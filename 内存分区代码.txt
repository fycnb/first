#include <cstdio>
#include <cstdlib>
#define item_count 100

typedef struct node{
	unsigned M_InitialAddress;
	unsigned M_ItemLength;
	unsigned M_Status;//0未分配；1分配
}m_item;

typedef struct M_node{
	m_item *m_itemset[item_count];
	int count;
	unsigned m_size;
}memory_field;

int CreateMemory(memory_field* &Im_field,unsigned mSize){
	m_item* Im_item = (m_item*)malloc(sizeof(m_item));
	Im_field = (memory_field*)malloc(sizeof(memory_field));
	if(Im_item == 0 || Im_field == 0){
		return 0;
	}
	Im_item->M_InitialAddress = 0;
	Im_item->M_ItemLength = mSize;
	Im_item->M_Status = 0;

	Im_field->m_size = mSize;
	Im_field->count = 0;
	Im_field->m_itemset[Im_field->count++] = Im_item;
	return 1;
}

int printMemory(memory_field* &Im_field){
	if(Im_field == NULL) return 0;
	printf("当前主存分配情况如下：\n");
	printf("---------------------------------------------------------------\n");
	for(int i=0;i<Im_field->count;i++){
		printf("\t分区号");
		printf("\t起始地址");
		printf("\t分区长度");
		printf("\t状态\n");
		printf("\t%d",i);
		printf("\t%d",Im_field->m_itemset[i]->M_InitialAddress);
		printf("\t%d",Im_field->m_itemset[i]->M_ItemLength);
		printf("\t%d",Im_field->m_itemset[i]->M_Status);
	}
	printf("\n---------------------------------------------------------------\n");
	return 1;
}

int InsertItem(memory_field* &Im_field,int position,m_item *newItem){
	if(Im_field == NULL){
		printf("找不到内存分配表\n");
		return 0;
	}	

	for(int i = Im_field->count - 1;i >= position;i--){
		Im_field->m_itemset[i + 1] = Im_field->m_itemset[i];
	}
	Im_field->count++;
	Im_field->m_itemset[position] = newItem;
	return 1;
}

int AllocateMemory(memory_field* &Im_field,unsigned worksize){
	for(int i = 0;i < Im_field->count;i++){
		m_item *item = Im_field->m_itemset[i];
		if(worksize <= item->M_ItemLength && item->M_Status == 0){
			if(worksize == item->M_ItemLength){
				item->M_Status = 1;
			} else {
				m_item *newItem = (m_item*)malloc(sizeof(m_item));
				newItem->M_InitialAddress = item->M_InitialAddress;
				newItem->M_ItemLength = worksize;
				newItem->M_Status = 1;

				item->M_InitialAddress += worksize;
				item->M_ItemLength -= worksize;
				item->M_Status = 0;

				InsertItem(Im_field,i,newItem);
			}
			return 1;
		}
	}
	return 0;
}

int DeleteItem(memory_field* &Im_field,int number){
	if(Im_field == NULL) return 0;
	free(Im_field->m_itemset[number]);
	for(int i = number; i < Im_field->count - 1;i++){
		Im_field->m_itemset[i] = Im_field->m_itemset[i + 1];
	}
	return 1;
}

int UpMergeMemory(memory_field* &Im_field,int &number){
	if(number > 0){
		int up = number - 1;
		unsigned int tmp_up =Im_field->m_itemset[up]->M_InitialAddress + Im_field->m_itemset[up]->M_ItemLength;
		if(tmp_up == Im_field->m_itemset[number]->M_InitialAddress && Im_field->m_itemset[up]->M_Status == 0){
			printf("正在进行向上合并，请等待...\n");
			Im_field->m_itemset[up]->M_ItemLength += Im_field->m_itemset[number]->M_ItemLength;
			DeleteItem(Im_field,number);
			Im_field->count--;
			number--;
		}
		return 1;
	}
	return 0;
}

int DownMergeMemory(memory_field* &Im_field,int &number){
	if(number < Im_field->count - 1){
		unsigned int tmp_down =Im_field->m_itemset[number]->M_InitialAddress + Im_field->m_itemset[number]->M_ItemLength;
		if(tmp_down ==  Im_field->m_itemset[number + 1]->M_InitialAddress && Im_field->m_itemset[number + 1]->M_Status == 0){
			printf("正在进行向下合并，请等待...\n");
			Im_field->m_itemset[number]->M_ItemLength += Im_field->m_itemset[number + 1]->M_ItemLength;
			DeleteItem(Im_field,number + 1);
			Im_field->count--;
		}
		return 1;
	}
	return 0;
}


int FreeMemory(memory_field* &Im_field,int number){
	if(Im_field == NULL || number >= Im_field->count){
		printf("内存分配表不存在或者内存分区不存在。");
		return 0;
	}
	Im_field->m_itemset[number]->M_Status = 0;
	if(UpMergeMemory(Im_field,number)){
		printf("上邻空闲分区合并成功。\n");
	}
	if(DownMergeMemory(Im_field,number)){
		printf("下邻空闲分区合并成功。\n");	
	}
	return 1;
}


int main(){
	unsigned mSize = 0;
	printf("欢迎使用最先适应法分配内存\n");
	printf("---------------------------------------------------------------\n");
	printf("1:  256MB\n");
	printf("2:  512MB\n");
	printf("3:  1024MB\n");
	printf("请选择内存大小：");
	bool status = true;
	int d = 0;
	while(status){
		status = false;
		scanf("%d",&d);
		switch (d)
		{
		case 1:{printf("您选择的内存大小为256MB\n");mSize = 256; break;}
		case 2:{printf("您选择的内存大小为256MB\n");mSize = 512; break;}
		case 3:{printf("您选择的内存大小为256MB\n");mSize = 1024; break;}
		default:{printf("输入错误，请重新输入：\n"); status = true; break;}
		}
	}
	memory_field *Im_field = 0;
	CreateMemory(Im_field,mSize);
	printMemory(Im_field);
	status = true;

	while(status){
		printf("请选择操作类型：\n");
		printf("1. 分配内存\n");
		printf("2. 释放内存\n");
		printf("3. 退出\n");
		scanf("%d",&d);
		switch (d)
		{
		case 1:{
				printf("请输入作业大小：");
				int worksize = 0;
				scanf("%d", &worksize);
				if(AllocateMemory(Im_field,worksize)){
					printf("\n分配成功。\n");
					printMemory(Im_field);
				} else {
					printf("\n主存不足，分配失败。\n");
				}
				break;
			   }
		case 2:{
			   printf("当前的主存分区号为0-%d，请输入要释放的主存区号：",Im_field->count-1);
			   int number = 0;
			   scanf("%d",&number);
			   if(FreeMemory(Im_field,number)){
					printf("\n释放成功。\n");
					printMemory(Im_field);
				}
			   else{
					printf("释放失败。\n");
				}
			   break;
			   }
		case 3:{
			return 0;}
		default:{
					printf("输入错误，请重新输入:\n");
					break;
				}
		
		}
	}
	system("pause");
	return 0;
}